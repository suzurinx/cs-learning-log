# binaryTree-reverse-inOrder 問題の解法メモ

## 内容

与えられた配列（レベル順）から二分木を生成し、その**逆中順走査（reverse in-order traversal）**の結果を配列として返す。

逆中順走査は「右→ルート→左」の順でノードを走査する。

## 実装ポイント

- toBinaryTree関数で配列からレベル順にノードを配置し、二分木を生成
    - queueを用いて、左右の子ノードを順に割り当てる
    - Noneは葉の欠損として扱う（ノードを生成しない）
- reverseInOrderTraversal関数はラッパー（wrapper）として、ヘルパー関数を呼び出し、結果をそのまま返す仕様
- reverseInOrderTraversalHelper関数で実際の再帰処理：
    - if root is not None: で進行条件を明示
    - 右→ルート→左の順に再帰を進めることで、逆中順の順序で値をリストへ追加
    - 戻り値としてarrを返す
- **ベースケースは「やるべきことがない＝何もしない」**というパターン
    - これにより、Noneノードではリストがそのまま維持され、探索が終わる設計
- 戻り値（arr）は「ノードのdataを値として保持する配列」
※ノードそのもの（参照）ではなく、**値（整数）**のみ格納

## テスト

```python

reverseInOrderTraversal(toBinaryTree([0,-10,5,None,-3,None,9]))
reverseInOrderTraversal(toBinaryTree([5,3,6,2,4,None,7]))
reverseInOrderTraversal(toBinaryTree([-2,-17,8,-18,-11,3,19,None,None,None,-4,None,None,None,25]))
reverseInOrderTraversal(toBinaryTree([1,-5,15,-9,-4,10,17,None,-6,None,0,None,14,16,19]))
reverseInOrderTraversal(toBinaryTree([3,-3,13,-7,1,6,18,-10,-4,0,2,5,8,15,19]))

```

## 出力

```python

[9, 5, 0, -3, -10]
[7, 6, 5, 4, 3, 2]
[25, 19, 8, 3, -2, -4, -11, -17, -18]
[19, 17, 16, 15, 14, 10, 1, 0, -4, -5, -6, -9]
[19, 18, 15, 13, 8, 6, 5, 3, 2, 1, 0, -3, -4, -7, -10]

```

## 気づき

**「再帰のベースケース＝何もしない」パターンの重要性**  
明示的なreturnやbreakで止めるだけでなく、「条件を満たすときだけ処理する」形でも、再帰は正しく動作する。

**再帰の「止め方」＝Do（やる条件）かSTOP（やめる条件）のどちらでもOK**  
教材ではSTOP型で教えることが多いが、Do型も表現可能なので両パターンに慣れておくと柔軟。

**「木構造でのイメージ」がコールスタックの理解を補う**  
コールスタックをすべて追わなくても、木構造上でどのノード・どのタイミングで値がリストに追加されるかを想像できれば、
再帰の正しい動作が理解できる。

**木構造ロジックの理解度**  
以前は木構造の再帰に対して「わからなさ」や「都度、混乱w」があったが、今回は細部のif条件や、リストへの値の追加ロジックにフォーカスできる余裕があった。

**条件の選び方**  
if root is not None: if not root: のような条件は、まだうまく選び取ることができない。

## まとめ

- 二分木の構築→再帰的な走査→値のコレクションという一連のパターンを、要件定義できるようになり手も動くようになってきた
- **定番パターン（イディオム）”**を利用してコーディングできるようになってきた
