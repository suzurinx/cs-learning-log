# binarytree-preoder-travasal 問題の解法メモ

## 内容
- 平衡二分探索木（BST）の**前順走査（pre-order traversal）**を実装し、木構造の各ノードの値を出力する
- 前順走査は「ルート → 左部分木 → 右部分木」の順番でノードを巡回する

## 実装ポイント

- 別のセクションでは、printする関数に走査する関数をネストして実装したが、走査の方法を意識するために、今回は走査とprintする操作を分けた
- 再帰処理で左・右部分木を順番に呼び出し、ノードの値を出力

## テストケース

```python

# テスト用配列
arr1 = [1,2,3,4,5,6,7,8,9,10,11]
arr2 = [4,43,36,46,32,7,97,95,34,8,96,35,85,1010,232]

# 平衡BSTを生成
bst1 = BinarySearchTree(arr1)
bst2 = BinarySearchTree(arr2)

# 前順走査で出力
bst1.root.printPreOrder()
bst2.root.printPreOrder()
```

## 出力

```python

6 3 1 2 5 4 9 7 8 11 10
43 8 7 36 32 34 35 97 46 85 96 95 1010 232

```

## 気づき
```python
def __init__(self, data, left = None, right = None):
```
この部分の `self` の扱いについて改めて振り返る。インスタンスを作成するために引数を受け取るわけだが、まず、`self` という箱を引き入れ、そこに順次 `left`, `right` を引き入れるイメージ

```python
self.data = data
# 例えば
self.cake = data
# でも良い
```
インスタンスの名前はここで設定するので、引数の名前と必ずしも同じである必要はない

## まとめ

- **走査パターン（前順・中順・後順）**は、出力順序の違いでしかないので、共通の枠組みで書き分けられる

- Pythonのselfやインスタンスメソッドの振る舞いなど、「わかっているつもり」だった基礎を再点検したことが深い学びになった

- 走査アルゴリズムは、木構造・再帰のイメージが掴めていれば、どんどん手を動かして実装できる