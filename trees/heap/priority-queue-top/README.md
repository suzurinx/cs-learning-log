# 問題名
優先度付きキューtop
## 問題内容
任意の整数配列から最大ヒープを構築し、常に最大値を取得できるデータ構造 PriorityQueue を実装する。内部的にはヒープ構造を使い、top() メソッドで最大値を取得できるようにする。
## 実装ポイント
#### 実装の方針：
- buildMaxHeap: 配列全体から最大ヒープを作成（トップダウン型）
- maxHeapify: 部分ヒープから最大構造を再帰で保証（ボトムアップ型）
- PriorityQueue: インスタンス初期化時に自動的に最大ヒープ化
#### 意識した制約・パフォーマンス：
- 各 maxHeapify の操作は O(log n)
- buildMaxHeap 全体では O(n) 時間で構築可能（解析上は線形）
#### 難所・分岐・構造上の注意点：
- スライス [:] によるシャローコピーの挙動
- maxHeapify による再帰と要素入れ替えの順序性の理解
- OOP設計と手続き型の切り分け（設計方針の一貫性）

## テストケース
```python
pq1 = PriorityQueue([2, 3, 43, 2, 53, 6, 75, 10])
print(pq1.top())  # 75

pq2 = PriorityQueue([3, 12, 0, 2, 9, 1, 65, 32])
print(pq2.top())  # 65

pq3 = PriorityQueue([1, 2, 3, 4, 8, 2, 1, 9, 7, 3, 4])
print(pq3.top())  # 9
```

# 実行結果
```python
75
65
9
```
## 気づき
- PriorityQueue をクラスで切る設計にすることで、状態を持たせて繰り返し使えるようになっている
- HeapLibrary を外出しにしているのは構造の理解用
- HeapLibrary のロジックを PriorityQueue 内に統合する方が責務が一貫する
- クラス化のメリットと、関数だけで完結させる方法のトレードオフを実感
## 再訪メモ
- [:] によるコピーが浅いことの意味を押さえる
- maxHeapify 再帰の中での index の追跡が自力で再現できるか
- OOPでの状態管理と、ライブラリ設計（関数分離）とのバランス
- HeapLibrary をそもそも必要とする設計だったのか

## 解いた日
2025-7-6