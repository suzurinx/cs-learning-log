# 問題名
最大ヒープ

## 問題内容
与えられた整数配列を**最大ヒープ（Max-Heap）**の構造に変換する関数を実装する。
最大ヒープとは、すべての親ノードが子ノード以上の値を持つ完全二分木。

## 実装ポイント
- heapify処理を再帰で実装し、buildMaxHeap関数内で最後の親ノードから順に適用
- heapSizeとiを引数で渡すことで再帰処理を制御
- 再帰的なswapで木全体を整える

#### 難所・分岐・構造上の注意点など
最後の親ノードの求め方について
- nは要素数、iはインデックス

- 要素数nの配列があったとき、最後のインデックスは n-1
- その最後の要素が左の子ノードになるためには、親ノードiが
- 2*i + 1 = n - 1 → 2*i = n - 2 → i = (n - 2) / 2 を満たす必要がある
- つまり
- n - 2 は、「**左の子が最後の要素に一致する、**ギリギリの親の位置」
- それ以下の i は 左の子が存在する確実なインデックス
- よって、i <= (n - 2) // 2 が「heapifyする必要がある最後の親ノード」を表す

## テストケース
```python
print(buildMaxHeap([1,2,3]))
print(buildMaxHeap([-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]))
print(buildMaxHeap([7,8,2,3,1,4,3,2]))
print(buildMaxHeap([8,4,13,10,18]))
print(buildMaxHeap([3,100,201,56,8,591,985,291]))
print(buildMaxHeap([879,487,98,397,610,150,474,977,404,478,623,554,306]))
```

# 実行結果
```python
[3, 2, 1]
[10, 7, 9, 5, 6, 8, 3, 4, 0, -2, 1, -3, 2, -1]
[8, 7, 4, 3, 1, 2, 3, 2]
[18, 10, 13, 8, 4]
[985, 291, 591, 100, 8, 3, 201, 56]
[977, 879, 554, 487, 623, 306, 474, 397, 404, 478, 610, 150, 98]
```
## 気づき
- 設計時に、関数間で同じ変数名を使う設計は意図的であるべきだと実感  
    → 呼び出し関数から渡す値で連動させることがポイント
- コードを書き進めながら変数設計を調整して揃えていく
- 一見複雑に見える構文も、役割がはっきりすれば読みやすくなる

## 再訪メモ
- 最後の親ノードの求め方は、次に復習する時にも見返す必要がある
- for i in range((n - 2) // 2, -1, -1) の理由が理解の鍵

## 解いた日
2025-07-04