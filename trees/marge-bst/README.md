# marge-bst 問題の解法メモ

## 内容
2つの二分探索木 `root1`, `root2` を合体（マージ）する関数 `mergeBST` を実装する  
- **重なっているノード**は「値を合計」した新ノードに
- **片方だけ存在するノード**はそのまま新しい木に利用
## 実装ポイント
- **再帰的アプローチ**で木を同じ位置同士で比較し、合成していく
    - **新しい木を構築する版**：すべて新ノードで生成、元の木は変更しない
    - **既存の構造を上書き・合成する版**：root1側の木を直接更新して返す（メモリ効率的）

- **ベースケース**
    - どちらかのノードが `None` なら、もう一方をそのまま返す
    - 再帰呼び出しなので、部分木（subtree）単位でも同様に適用される

- **出力整形**
    - `BinaryTree` のままだとメモリ先が出力されるだけなので、in-order（中間順）でリスト化する関数も実装
    - 木の生成も `toBinaryTree` で「キュー型」「再帰型（内部関数型/ヘルパー）」など複数のパターンで練習
## テストケース
```python
print(toListInOrder(mergeBST(toBinaryTree([]), toBinaryTree([]))))
print(toListInOrder(mergeBST(toBinaryTree([0]), toBinaryTree([]))))
print(toListInOrder(mergeBST(toBinaryTree([44,12,82,2,21,70,88,None,9,18,42,66,80,83,97]), toBinaryTree([48,24,74,7,39,51,83,None,10,27,44,None,71,77,86]))))
print(toListInOrder(mergeBST(toBinaryTree([42,10,87,2,29,53,92,None,8,14,36,43,76,90,96]), toBinaryTree([57,31,76,26,45,68,94,8,27,39,46,64,74,78,96,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,99]))))
print(toListInOrder(mergeBST(toBinaryTree([45,10,69,3,12,63,75,None,None,None,30,None,None,None,85]), toBinaryTree([53,10,70,6,31,60,88,3,8,15,33,54,66,79,93,None,4,None,9,None,22,None,46,None,58,None,69,None,80,91,98]))))
```
## 出力
```python
[]
[0]
[9, 19, 36, 45, 60, 86, 92, 66, 121, 151, 156, 160, 171, 183]
[8, 28, 35, 41, 53, 74, 82, 99, 107, 121, 150, 163, 168, 186, 192, 99]
[3, 4, 9, 8, 9, 20, 15, 22, 43, 63, 46, 98, 54, 58, 123, 66, 69, 139, 79, 80, 163, 91, 178, 98]
```
## 気づき
- 再帰ベースケースの**本当の役割**（材料提供にもなる！）を体感できた
- 新しい木を返す・既存を上書き、**2通りの設計**が明確に理解できた
- 二分木の生成や出力方法も**複数パターン**を比較しながら実装できた
- `print` での確認とリストでの可視化の違い（アウトプット整形の重要性）も再確認
- if条件やreturnの使い方ひとつで、**再帰の制御がガラッと変わる**ことを体感した