# bst-key-exists 問題の解法メモ

## 内容

- 配列から平衡二分探索木（BST）を構築し、中順走査で木構造を出力する問題
- 木構造のルートノードには、配列の中央値を再帰的に選び、左右に振り分けることでバランスを保つ

## 実装ポイント

- `sortedArrayToBST` を **@staticmethod** で実装し、BSTの初期化時に利用
- 出力用の `printInOrder` メソッドは BinaryTree 側に持たせて、木構造本体だけで中順走査ができるように設計
- `printInOrder` の実装は、ネスト関数で再帰的に左→自身→右を巡る構造

## テストケース
```python
balancedBST = BinarySearchTree([1,2,3,4,5,6,7,8,9,10,11])
balancedBST2 = BinarySearchTree([4,43,36,46,32,7,97,95,34,8,96,35,85,1010,232])
balancedBST.printSorted()
balancedBST2.printSorted()
```
## 出力

```python
1 2 3 4 5 6 7 8 9 10 11
4 7 8 32 34 35 36 43 46 85 95 96 97 232 1010
```

## 気づき

- printInOrder をネストで実装したが、小さな関数で隠蔽する意義はほとんどないと実感
（“隠す”設計でもPythonでは実質丸見え。無理に分けなくてOK）
- `@staticmethod` は「インスタンス変数を使わない関数」に対してつけるもの
    → 関数設計・呼び出しの明示化には有効だけど、強制力はない

## まとめ
- 「どこからルートが渡るのか」や「.（ドット）によるアクセスの仕組み」まで理解できた
- クラスの責務と設計意図を自分の視点で納得できるようになった
- 今後も“本当に分ける必要があるか？”を考えながら、シンプルな設計を優先する方針で進める