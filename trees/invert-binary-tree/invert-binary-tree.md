# bst-key-exists 問題の解法メモ

## 内容
- 二分木（BinaryTree）を左右反転（invert）する関数 invertTree を実装する問題
- 入力はリスト（配列）表現で与えられ、レベル順で木構造に変換された後に反転処理を行う
- 出力は反転後の二分木を、再びレベル順リストで表現したもの

## 実装ポイント
- 再帰版／キュー（BFS）版のどちらでも解法が成立する
- 再帰版：左右の子ノードを再帰的に入れ替える
- キュー版：レベル順でノードを順に処理し、左右の子をスワップ
- 入出力変換（リスト⇄木⇄リスト）は、本番環境ではラッパー関数でブラックボックス化されているが、自作環境ではtoBinaryTreeやtoListBFS等の補助関数を用意して実現

## テストケース
```python
print(invertTree(toBinaryTree([1, 3, 8, 2, 5, 7, 10])))
print(invertTree(toBinaryTree([])))
print(invertTree(toBinaryTree([5, 4, 3, None, None, 8])))
print(invertTree(toBinaryTree([16, 14, 10, 8, 7, 9, 3, 2, 4, 1])))
```
## 出力
- テストケースは、反転後の二分木をレベル順（BFS）でリスト化した形になる  
例：
- [1, 3, 8, 2, 5, 7, 10] → 反転 → [1, 8, 3, 10, 7, 5, 2]
- [] → 反転 → []
- [5, 4, 3, None, None, 8] → 反転 → [5, 3, 4, None, 8]
- [16, 14, 10, 8, 7, 9, 3, 2, 4, 1] → 反転 → [16, 10, 14, 3, 9, 7, 8, None, None, None, None, None, 1, 4, 2]

## 気づき
- 入力・出力の整形は「ラッパー関数（toBinaryTree, toListBFS）」が裏で処理していることが多い
- 木の反転アルゴリズム自体はシンプルだが、入出力変換を自作すると難易度が大きく上がる
- 出力形式やテストコードによっては、リストの末尾のNoneの扱いにも注意が必要
- 自分の環境で完璧に出力整形まで揃えられると、どんな実装課題にも柔軟に対応できるスキルが身につく