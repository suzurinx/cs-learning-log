# 問題名
<!-- 問題のタイトルを簡潔に記載 -->
文字列の最大値

## 問題内容
<!-- 問題の概要、何を求められているかを自分の言葉で整理 -->
配列の中から「最大の文字列」を返す関数 `maxByCriteria` を実装する。  
「最大」の基準は別の比較関数（例：長さ比較やASCII合計値比較）として渡される。

## 実装ポイント

### 実装方針
<!-- 再帰 / ループ / DFS / BFS など、選んだアプローチと理由 -->
- 比較関数を引数に受け取る高階関数 `maxByCriteria` を定義
- 配列の最初の要素を仮の最大値とし、以降をループで走査
- 比較関数の評価結果に応じて最大値を更新

### 意識した制約・パフォーマンス
<!-- 実装時に気をつけた制約や、時間・空間効率をどう考慮したか -->
- 配列の要素数を `n` として、計算量は O(n)

### 難所・分岐・構造上の注意点
<!-- 実装中につまずいた部分、注意が必要だった構造や分岐条件など -->
- 配列の要素数を `n` として、計算量は O(n)
- 不要な `sum()` の重複を避けるため、ASCII 合計の計算は変数に格納してから比較

### 設計判断メモ（※なぜこの方法を選んだか）
<!-- 他の方法との比較・利点・設計上の意思決定を言語化 -->
- 仮最大値を設定し、ループ内で更新していくのは実践的な基本構造
- 可読性を保ちつつ、関数を再利用可能に保つために分離した設計にした

## テストケース
<!-- 入力と期待される出力をセットで記載 -->
```python
print(maxByCriteria(compareLength, ["apple", "yumberry", "grape", "banana","mandarin"]))  # mandarin
print(maxByCriteria(compareLength, ["zoomzoom", "choochoo", "beepbeep", "ahhhahhh"]))     # ahhhahhh
print(maxByCriteria(compareAsciiTotal, ["apple", "yumberry", "grape", "banana","mandarin"]))  # yumberry
print(maxByCriteria(compareAsciiTotal, ["zoom", "choochoo", "beepbeep", "ahhhahhh"]))         # choochoo
```

## 出力
<!-- 実際に得られた出力結果を記録 -->
```python
mandarin
ahhhahhh
yumberry
choochoo
```

## 気づき
<!-- 実装中・実行後に得た新しい知見や発見を記録。構文、挙動、制約など何でもOK -->
- sum(ord(c) for c in s) のような構文は読めるようになっていた
- 「仮最大値」の考え方は応用範囲が広く、今後も使える
- 以前に学んだことが、活きているという実感があった

## 再訪メモ

### 不安な構文・表現
<!-- 曖昧だった構文や、処理の流れが読み切れなかった部分 -->
- ord() の用途と動作（ASCII変換）は忘れていたが、一度確認すれば理解は早かった

### 理解しきれなかった組み合わせの構文
<!-- 複数の構文が組み合わさった時に直感で読めなかったものなど -->
- 特になし

### 次に類似問題を解くときに注目したいポイント
<!-- 次回似た問題に出会ったときの指針。再利用したい構造など -->
- 比較関数を渡す形式（コールバック構造）
- スライスとfor文の併用による走査パターン
- 条件式の不等号が意味に与える影響

## 解いた日
2025-07-13
